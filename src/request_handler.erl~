%%%-------------------------------------------------------------------
%%% @author mb-spare
%%% @copyright (C) 2016, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 05. May 2016 11:24 PM
%%%-------------------------------------------------------------------
-module(request_handler).
-author("mb-spare").

%% API
-export([handle_request/1]).
-include("../include/chapchap_app_common.hrl").

%%--------------------------------------------------------------------
%% @doc
%% This will handle a reqeust based on a Request record provided
%% It will return a request_return record
%% @end
%%--------------------------------------------------------------------
-spec(handle_request(Request :: #chapchap_request{})-> Return :: #chapchap_request_return{}).
handle_request(InitialRequest = #chapchap_request{processor = Processor,name = Name,type = Type}) ->
  case http_auth:perform_auth(InitialRequest) of
    {ok, Usr} ->
      case lists:member(Processor, ?ALLOWED_PROCESSORS) of
        true ->

          %% get unique id for this request
          IdReturn = get_request_id(InitialRequest),
          case IdReturn of
            {error,IdError} -> chapchap_request_return:process(IdError);
            {ok,Id} ->
              Request = InitialRequest#chapchap_request{request_id =Id,api_user = Usr},

              %% get initial process step
              ProcessStep = get_process_step(Request),

              %% start an archiver for this request
              {ok, ArchiverPid} = archiver_sup:start_archiver_with_state(#archiver_state{type = Type,id = Id,process_step = ProcessStep}),

              %% create record, particular types may have different records, else they will return the Request record
              Record = Type:create_record(Request#chapchap_request{archiver_pid = ArchiverPid}),
              %% service the request
              ChapchapRequestReturn =  process_request_internal(Type,Name,Record,Id),
              chapchap_request_return:process(ChapchapRequestReturn)
          end;
        false ->
          ProcessorError = <<"processor in url not allowed">>,
         chapchap_request_return:process(ProcessorError)
      end;
    {error, AuthError} ->
      io:format("AuthError: \t~p~n", [AuthError]),
      chapchap_request_return:process(AuthError)

  end.

%%--------------------------------------------------------------------
%% @doc
%% Return the initial process step,
%% it will be zero for basic operations
%% reqeusts that have more than one operation may provide different
%% initial process_step based on whic operation it is
%% @end
%%-------------------------------------------------------------------
-spec(get_process_step(Request :: #chapchap_request{})-> integer()).
get_process_step(#chapchap_request{operation = basic})->
  0;
get_process_step(Request = #chapchap_request{type = Type})->
  Type:get_process_step(Request).

%%--------------------------------------------------------------------
%% @doc
%% Return a unique id for the reqeust,
%% it will be a guid for a basic operation
%% reqeusts that have more than one operation may have to get the transaction id from an
%% existing process or from the database since it is the same request but different
%% operation
%% @end
%%-------------------------------------------------------------------
-spec(get_request_id(Request :: #chapchap_request{})-> {ok,binary()} | {error , Error :: term()}).
get_request_id(#chapchap_request{operation = basic})->
  {ok,number_manipulator:get_guid()};
get_request_id(Request = #chapchap_request{type = Type})->
  Type:get_request_id(Request).

process_request_internal(Type,Name,Record,Id)->
  try
    Type:Name(Record)
  catch
    X:{Y, _N} when is_atom(Y) ->
      Trace = io_lib:format("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [X, Id, Y, erlang:get_stacktrace()]),
      error_logger:error_msg("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [X, Id, Y, erlang:get_stacktrace()]),
      MessageBinaryToAtom = atom_to_binary(Y, utf8),
      Message = re:replace(MessageBinaryToAtom, ?underscore_global_regex, " ", [{return, binary}, global]),
      Type:archive(Record,?STATE_PROCESSING_ERROR,Trace,Message),
      #chapchap_request_return{success = false, message = Message,request_id = Id};
    throw:Y when is_atom(Y) ->
      Trace = io_lib:format("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [throw, Id, Y, erlang:get_stacktrace()]),
      error_logger:error_msg("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [throw, Id, Y, erlang:get_stacktrace()]),  MessageBinaryToAtom = atom_to_binary(Y, utf8),
      Message = re:replace(MessageBinaryToAtom, ?underscore_global_regex, " ", [{return, binary}, global]),
      Type:archive(Record,?STATE_PROCESSING_ERROR,Trace,Message),
      #chapchap_request_return{success = false, message = Message,request_id = Id};
    throw:Y ->
      Trace = io_lib:format("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [throw, Id, Y, erlang:get_stacktrace()]),
      error_logger:error_msg("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [throw, Id, Y, erlang:get_stacktrace()]),
      Message = atom_to_binary(Y, utf8),
      Type:archive(Record,?STATE_PROCESSING_ERROR,Trace,Message),
      #chapchap_request_return{success = false, message = Message,request_id = Id};
    X:Y ->
      Trace = io_lib:format("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [X, Id, Y, erlang:get_stacktrace()]),
      error_logger:error_msg("error has occurred of type: ~w transaction_id: ~w , message: ~w trace ~w  \n", [X, Id, Y, erlang:get_stacktrace()]),
      Type:archive(Record,?STATE_PROCESSING_ERROR,Trace,?ERROR_MESSAGE_FATAL),
      #chapchap_request_return{success = false, message = ?ERROR_MESSAGE_FATAL,request_id = Id}
  end.
