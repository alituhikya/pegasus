%%%-------------------------------------------------------------------
%%% @author MB-SPARE
%%% @copyright (C) 2015, <COMPANY>
%%% @doc
%%% generates queries
%%% @todo change to binaries:: lists_to_binary can concatenate
%%% @todo string:tokens  and io:format("~p~n",[B]) for consideration for trace and message
%%% @todo consider binary_to_term and term_to_binary for trace and message
%%% @end
%%% Created : 19. Nov 2015 5:48 PM
%%%-------------------------------------------------------------------
-module(query_builder).
-author("alituhikyaj").

-include("../include/chapchap_app_common.hrl").
-include("../deps/authenticator/include/usr.hrl").

%% Queries
-export([
  batch_insert_from_transaction/1,
  batch_insert_agents_transaction/1,
  batch_insert_customers_transaction/1,
  batch_insert_service_providers_transaction/1,
%%update_counter/1,
  batch_insert_from_request/1,
  read_transaction_by_id/1,
  read_customer_by_phone_number/1,
  read_agent_by_phone_number/1,
  batch_insert_from_agent/1,
  batch_insert_from_customer/1,
  read_request_by_id/1,
  insert_child/1,
  update_child_count/1,
  update_agents_customer_count/1,
  insert_agents_customer/1,
  update_accounts/1,
  read_account_total/1,
  agent_update_licensed/1,
  agent_update_activated/1,
  agent_update_blocked/1,
  customer_update_activated/1,
  customer_update_blocked/1,
  read_agents_children/3,
  read_agents_child_count/1,
  insert_account_actions/1,
  read_account_action_by_id/1,
  pg_transfer_amount/3,
  pg_update_account/1,
  pg_get_account_total/1,
  pg_create_account/1,
  read_agents_customer/3,
  read_agents_customer_count/1
]).


%%-----------------------------
%% @doc this will return the insert statement and values for a transactions
%% it returns a list of tuples of the form {Statement, Values}
%%-------------------------------
-spec(batch_insert_from_transaction(Transaction :: #chapchap_transaction{}) ->List :: list()).
batch_insert_from_transaction(Transaction = #chapchap_transaction{args_list = _ArgsList}) ->
  {_TimestampNow, _TimestampToday, TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  {Params, Values, Names, QuestionMarks} = get_transaction_params(Transaction),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampMonth, Params, Values, Names, QuestionMarks),

  [
    {"INSERT INTO transaction_by_id(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");", Params}
%%     {"INSERT INTO transaction_by_state(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
%%     {"INSERT INTO transaction_by_user_type(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket}
  ].


%%-----------------------------
%% @doc this will return the insert statement and values for a transactions
%% it returns a list of tuples of the form {Statement, Values}
%% @todo query runner test
%%-------------------------------
-spec(batch_insert_customers_transaction(Transaction :: #chapchap_transaction{}) ->List :: list()).
batch_insert_customers_transaction(Transaction = #chapchap_transaction{args_list = _ArgsList}) ->
  {_TimestampNow, _TimestampToday, TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  {Params, Values, Names, QuestionMarks} = get_transaction_params(Transaction),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampMonth, Params, Values, Names, QuestionMarks),

  [
    {"INSERT INTO transaction_by_id(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");", Params},
    {"INSERT INTO transaction_by_state(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
    {"INSERT INTO transaction_by_user_type(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
    {"INSERT INTO transaction_by_customer(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket}
    ]
  .

%%-----------------------------
%% @doc this will return the insert statement and values for a transactions
%% it returns a list of tuples of the form {Statement, Values}
%% @todo query runner test
%%-------------------------------
-spec(batch_insert_agents_transaction(Transaction :: #chapchap_transaction{}) ->List :: list()).
batch_insert_agents_transaction(Transaction = #chapchap_transaction{args_list = _ArgsList}) ->
  {_TimestampNow, _TimestampToday, TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  {Params, Values, Names, QuestionMarks} = get_transaction_params(Transaction),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampMonth, Params, Values, Names, QuestionMarks),

  [
    {"INSERT INTO transaction_by_id(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");", Params},
    {"INSERT INTO transaction_by_state(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
    {"INSERT INTO transaction_by_user_type(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
    {"INSERT INTO transaction_by_agent(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket}
  ]
.

%%-----------------------------
%% @doc this will return the insert statement and values for a transactions
%% it returns a list of tuples of the form {Statement, Values}
%% @todo query runner test
%%-------------------------------
-spec(batch_insert_service_providers_transaction(Transaction :: #chapchap_transaction{}) ->List :: list()).
batch_insert_service_providers_transaction(Transaction = #chapchap_transaction{args_list = _ArgsList}) ->
  {_TimestampNow, _TimestampToday, TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  {Params, Values, Names, QuestionMarks} = get_transaction_params(Transaction),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampMonth, Params, Values, Names, QuestionMarks),
  [
    {"INSERT INTO transaction_by_id(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");", Params},
    {"INSERT INTO transaction_by_state(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
    {"INSERT INTO transaction_by_user_type(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket},
    {"INSERT INTO transaction_by_service_provider(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");", ParamsBucket}
  ]
.


%%-----------------------------
%% @doc this will return the insert statement and values for a request record
%% it returns a list of tuples of the form {Statement, Values}
%%-------------------------------
-spec(batch_insert_from_request(Request :: #chapchap_request{}) ->List :: list()).
batch_insert_from_request(Request) ->
  {TimestampNow, _TimestampToday, TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  Trace = case Request#chapchap_request.trace of
            undefined -> undefined;
            Else -> lists:flatten(io_lib:format("~p", [Else]))

          end,
  Message = case Request#chapchap_request.message of
              undefined -> undefined;
              Else1 -> lists:flatten(io_lib:format("~p", [Else1]))
             end,
  ApiUser = util:get_user(Request#chapchap_request.api_user),
  HandleIsNotBinary = fun(Value) when is_binary (Value) -> Value;
    (Value)-> lists:flatten(io_lib:format("~p", [Value])) end,
  ArgsList =
    case Request#chapchap_request.args_list of
      TheArgsList when is_list(TheArgsList) ->[{Key,HandleIsNotBinary(TheValue)} || {Key,TheValue} <-TheArgsList ];
      _ -> undefined
    end,

  RawParams = [
    {id,Request#chapchap_request.request_id},
    {args_list, ArgsList},
    {api_user, ApiUser},
    {retry_count, Request#chapchap_request.retry_count},
    {max_retry_count, Request#chapchap_request.max_retry_count},
    {trace, Trace},
    {state,Request#chapchap_request.state},
    {message, Message},
    {time, TimestampNow},
    {operation, Request#chapchap_request.operation},
    {type, Request#chapchap_request.type},
    {process_step, Request#chapchap_request.process_step},
    {processor, Request#chapchap_request.processor_name},
    {name, Request#chapchap_request.name},
    {api_user_type,Request#chapchap_request.api_user_type}

  ],
  Params = [{Key, Value} || {Key, Value} <- RawParams, Value /= undefined],
  Values = [Value || {_Key, Value} <- Params],
  Names = list_util:drop_last(lists:flatten([util:atom_to_string(Key) ++ "," || {Key, _Value} <- Params])),
  QuestionMarks = get_question_marks(length(Values)),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampMonth, Params, Values, Names, QuestionMarks),
  [
    {"INSERT INTO request_by_id(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");",Params},
    {"INSERT INTO request_by_state(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket},
    {"INSERT INTO request_by_user_type(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket},
    {"INSERT INTO request_by_user(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket}
  ].

%%-----------------------------
%% @doc this will return the insert statement and values for an agent record
%% it returns a list of tuples of the form {Statement, Values}
%%-------------------------------
-spec(batch_insert_from_agent(Agent :: #agent{}) ->List :: list()).
batch_insert_from_agent(Agent)->
  {_TimestampNow, _TimestampToday, _TimestampMonth, TimestampYear} = util:getTimeStamps(),
  RawParams = get_agent_params(Agent),
  Params = [{Key, Value} || {Key, Value} <- RawParams, Value /= undefined],
  Values = [Value || {_Key, Value} <- Params],
  Names = list_util:drop_last(lists:flatten([util:atom_to_string(Key) ++ "," || {Key, _Value} <- Params])),
  QuestionMarks = get_question_marks(length(Values)),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampYear, Params, Values, Names, QuestionMarks),
  [
    {"INSERT INTO agent_by_phone_number(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");",Params},
    {"INSERT INTO agent_by_country(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket}
  ].


%%-----------------------------
%% @doc this will return the insert statement and values for inserting a child agent (by level)
%% it returns a tuple of the form {Statement, Values}
%%-------------------------------
-spec(insert_child(Agent :: #agent{}) ->{Statment :: string(), Values :: list()}).
insert_child(Agent)->
  {_TimestampNow, _TimestampToday, _TimestampMonth, TimestampYear} = util:getTimeStamps(),
  RawParams = [{agent_level,Agent#agent.agent_level}|get_agent_params(Agent)],
  Params = [{Key, Value} || {Key, Value} <- RawParams, Value /= undefined],
  Values = [Value || {_Key, Value} <- Params],
  Names = list_util:drop_last(lists:flatten([util:atom_to_string(Key) ++ "," || {Key, _Value} <- Params])),
  QuestionMarks = get_question_marks(length(Values)),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampYear, Params, Values, Names, QuestionMarks),
    {"INSERT INTO child_by_agent_by_level(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket}.



%%-----------------------------
%% @doc updates an agent's child count at a particular level
%%
%%-------------------------------
-spec(update_child_count(Agent :: #agent{}) ->{Statment :: string(), Values :: list()}).
update_child_count(Agent)->
    {<<"UPDATE child_count_by_agent_by_level SET total = total + 1 WHERE parent_phone_number=? and agent_level=?">>,
      [{parent_phone_number,Agent#agent.parent_phone_number},{agent_level,Agent#agent.agent_level}]}.

%%-----------------------------
%% @doc reads children for whom the agent provided is at the level provided
%%
%%-------------------------------
-spec(read_agents_children(AgentPhoneNumber :: binary(),Level :: integer(), Year :: integer())->{binary(),list()}).
read_agents_children(AgentPhoneNumber,Level,Year)->
  {<<"SELECT * FROM child_by_agent_by_level WHERE bucket = ? and parent_phone_number = ? and agent_level = ?">>,
    [{parent_phone_number,AgentPhoneNumber},{bucket,Year},{agent_level,Level}]
  }.

%% @doc reads an agents child count
-spec(read_agents_child_count(Agent :: #agent{})->{binary(),list()}).
read_agents_child_count(Agent)->
  {<<"SELECT * FROM child_count_by_agent_by_level WHERE parent_phone_number = ?">>,
    [{parent_phone_number,Agent#agent.agent_phone_number}]
  }.


%%-----------------------------
%% @doc reads customer for whom the agent provided is at the level provided
%%
%%-------------------------------
-spec(read_agents_customer(AgentPhoneNumber :: binary(),Level :: integer(), Year :: integer())->{binary(),list()}).
read_agents_customer(AgentPhoneNumber,Level,Year)->
  {<<"SELECT * FROM customer_by_agent_by_level WHERE bucket = ? and agent_phone_number = ? and agent_level = ?">>,
    [{agent_phone_number,AgentPhoneNumber},{bucket,Year},{agent_level,Level}]
  }.



%% @doc reads an agents customer count
-spec(read_agents_customer_count(Agent :: #agent{})->{binary(),list()}).
read_agents_customer_count(Agent)->
  {<<"SELECT * FROM customer_count_by_agent WHERE agent_phone_number = ?">>,
    [{agent_phone_number,Agent#agent.agent_phone_number}]
  }.


%%-----------------------------
%% @doc this will return the insert statement and values for an agent record
%% it returns a list of tuples of the form {Statement, Values}
%%-------------------------------
-spec(batch_insert_from_customer(Customer :: #customer{}) ->List :: list()).
batch_insert_from_customer(Customer)->
  {_TimestampNow, _TimestampToday, _TimestampMonth, TimestampYear} = util:getTimeStamps(),
  RawParams =get_customer_params(Customer),
  Params = [{Key, Value} || {Key, Value} <- RawParams, Value /= undefined],
  Values = [Value || {_Key, Value} <- Params],
  Names = list_util:drop_last(lists:flatten([util:atom_to_string(Key) ++ "," || {Key, _Value} <- Params])),
  QuestionMarks = get_question_marks(length(Values)),
  {ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampYear, Params, Values, Names, QuestionMarks),
  [
    {"INSERT INTO customer_by_phone_number(" ++ Names ++ ") VALUES (" ++ QuestionMarks ++ ");",Params},
    {"INSERT INTO customer_by_country(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket}
  ].


%%-----------------------------
%% @doc this will return the insert statement and values for inserting an agent's customer (by level)
%% it returns a tuple of the form {Statement, Values}
%%-------------------------------
-spec(insert_agents_customer(Customer :: #customer{}) ->{Statment :: string(), Values :: list()}).
insert_agents_customer(Customer)->
{_TimestampNow, _TimestampToday, _TimestampMonth, TimestampYear} = util:getTimeStamps(),
RawParams = [{agent_level,Customer#customer.agent_level}|get_customer_params(Customer)],
Params = [{Key, Value} || {Key, Value} <- RawParams, Value /= undefined],
Values = [Value || {_Key, Value} <- Params],
Names = list_util:drop_last(lists:flatten([util:atom_to_string(Key) ++ "," || {Key, _Value} <- Params])),
QuestionMarks = get_question_marks(length(Values)),
{ParamsBucket, _ValuesBucket, NamesBucket, QuestionMarksBucket} = add_bucket(TimestampYear, Params, Values, Names, QuestionMarks),
{"INSERT INTO customer_by_agent_by_level(" ++ NamesBucket ++ ") VALUES (" ++ QuestionMarksBucket ++ ");",ParamsBucket}.


%%-----------------------------
%% @doc updates an agent's customer count at a particular level
%%
%%-------------------------------
-spec(update_agents_customer_count(Customer :: #customer{}) ->{Statment :: binary(), Values :: list()}).
update_agents_customer_count(Customer)->
    {<<"UPDATE customer_count_by_agent SET total = total + 1 WHERE agent_phone_number=? and agent_level=?">>,
      [{agent_phone_number,Customer#customer.agent_phone_number},{agent_level,Customer#customer.agent_level}]}.


%%-----------------------------
%% @doc retrieves a transaction by it's transaction id
%%-------------------------------
-spec(read_transaction_by_id(Transaction :: #chapchap_transaction{}) ->{Statment :: binary(), Values :: list()}).
read_transaction_by_id(Transaction)->
  {<<"SELECT * FROM transaction_by_id WHERE transaction_id = ?">>,
    [{transaction_id,Transaction#chapchap_transaction.transaction_id}]}.


%%-----------------------------
%% @doc generates query to retrieve a request by it's request id
%%-------------------------------
-spec(read_request_by_id(Request :: #chapchap_request{}) ->{Statment :: binary(), Values :: list()}).
read_request_by_id(Request)->
  {<<"SELECT * FROM request_by_id WHERE id = ?">>,
    [{id,Request#chapchap_request.request_id}]}.



%%-----------------------------
%% @doc generates query to retrieve a customer by their phone number
%%-------------------------------
-spec(read_customer_by_phone_number(Customer :: #customer{}) ->{Statment :: binary(), Values :: list()}).
read_customer_by_phone_number(Customer)->
  {<<"SELECT * FROM customer_by_phone_number WHERE customer_phone_number = ?">>,
  [{customer_phone_number,Customer#customer.customer_phone_number}]
  }.


%%-----------------------------
%% @doc generates query to retrieve an agent by their phone number
%%-------------------------------
-spec(read_agent_by_phone_number(Agent :: #agent{}) ->{Statment :: binary(), Values :: list()}).
read_agent_by_phone_number(Agent)->
  {<<"SELECT * FROM agent_by_phone_number WHERE agent_phone_number = ?">>,
    [{agent_phone_number,Agent#agent.agent_phone_number}]
  }.


%%------------------------------------
%% @doc this will return the postgres query to increment an account
%%-------------------------------------
pg_update_account(#account_action{account_number = PhoneNumber,amount = Amount})->
  {
    "UPDATE account SET total=total+$1 WHERE phone_number=$2; ", [Amount,PhoneNumber]
  }.

%%------------------------------------
%% @doc this will return the postgres query to transafer an amount from one account to another account
%%-------------------------------------
pg_transfer_amount(Amount,From,To)->
  {
    "BEGIN TRANSACTION;UPDATE account SET total=total-$1 WHERE phone_number=$2; UPDATE account SET total=total+$3 WHERE phone_number=$4; END;",
    [Amount,From,Amount,To]
  }.

%%------------------------------------
%% @doc this will return a postgresql query to retrieve current total of an account
%%-------------------------------------
-spec(pg_get_account_total(PhoneNumber :: string() | binary())->{string(),list()}).
%% pg_get_account_total (PhoneNumber) when is_binary(PhoneNumber)->
%%   pg_get_account_total(binary_to_list(PhoneNumber));
pg_get_account_total (PhoneNumber)->
  {
    "SELECT total FROM account WHERE phone_number = $1;",
    [PhoneNumber]
  }.

%%------------------------------------
%% @doc this will return the postgresql query to create an account
%%-------------------------------------
-spec(pg_create_account(PhoneNumber :: string())->{string(),list()}).
pg_create_account(PhoneNumber) when is_binary(PhoneNumber)->
  pg_create_account(binary_to_list(PhoneNumber));
pg_create_account(PhoneNumber)->
  {"insert into account (phone_number,total) values  ($1,0);", [PhoneNumber]}.

%%----------------------------------------------------------------------------------
%% @doc this will generate queries to update the accounts prescribed in the list of Account actions it receives as parameters
%% <p>It requires a list of account_action records</p>
%% <p>It returns a list of tuples of the form {Statment, Values}</p>
%%------------------------------------------------------------------------------
-spec(update_accounts(AccountActions :: list()) -> list()).
update_accounts(AccountActions) ->
  Function = fun(#account_action{amount = Amount,account_type = AccountType, account_number = AccountNumber},{V0,L})->
    %% handling for floating points
    %% precision will be 2 decimal placess
    %% value will be multiplied by 100 on insert so has to be divided by 100 on retrival

    V =
      case Amount of
       A when is_integer(A) -> 0;
       AA ->
         ((AA -trunc(AA)) * 100) + V0
      end,
    Query = {<<"UPDATE account SET total = total + ? WHERE account_number=? and account_type=?">>,
    [{total,Amount},{account_number,AccountNumber},{account_type,AccountType}]},
    {V,[Query|L]}
   end,

  {VaultCents, Queries} = lists:foldl(Function,{0,[]},AccountActions),
  VaultCentsName = <<"vault_cents">>,

  case VaultCents of
    VaultInt when is_integer(VaultInt) andalso VaultInt > 0 ->
      [ {<<"UPDATE account SET total = total + ? WHERE account_number=? and account_type=?">>,
        [{total,VaultInt},{account_number,VaultCentsName},{account_type,VaultCentsName}]}
        | Queries
      ];
    Vault when Vault > 0 -> [ {<<"UPDATE account SET total = total + ? WHERE account_number=? and account_type=?">>,
      [{total,trunc(Vault)},{account_number,VaultCentsName},{account_type,VaultCentsName}]}
      | Queries
    ];
    _ -> Queries

  end.


%%------------------------------------------------
%% @doc generate batch query to insert account actions
%%-----------------------------------------------------
insert_account_actions(AccountActions)->
  {_TimestampNow, _TimestampToday, TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  Tables = [
       "account_by_transaction_id",
       "account_by_account_number",
       "account_by_account_type"
  ],

  %% two list comprehensions
  %% outer one for each table
  %% inner one for each account action record
lists:flatten(
  [
    [
      {"INSERT INTO " ++ Table ++" (amount,account_number,account_type,transaction_id,bucket,time_uuid) VALUES (?,?,?,?,?,now() );",
      [{amount,Amount},{account_number,AccountNumber},{account_type,AccountType},{transaction_id,TransactionId},{bucket,TimestampMonth}]}
      || Table <- Tables
    ]
    || #account_action{amount = Amount,account_type = AccountType, account_number = AccountNumber,transaction_id = TransactionId} <- AccountActions
  ])
.


%%----------------------------
%% @doc generates query to retrieve the account action by transaction_id and account type
%%-------------------------------
-spec(read_account_action_by_id(AccountAction :: #account_action{}) ->{Statment :: string(), Values :: list()}).
read_account_action_by_id(TransactionId)->
  {<<"SELECT * FROM account_by_transaction_id WHERE transaction_id = ?">>,
    [{transaction_id,TransactionId}]
  }.



%%----------------------------
%% @doc generates query to retrieve the account total by account number and account type
%%-------------------------------
-spec(read_account_total(AccountAction :: #account_action{}) ->{Statment :: string(), Values :: list()}).
read_account_total(#account_action{account_number = AccountNumber ,account_type = AccountType})->
{<<"SELECT total FROM account WHERE account_number = ? and account_type=?">>,
[{account_number,AccountNumber},{account_type,AccountType}]
}.



%%----------------------------
%% @doc generates query to license or revoke license of an agent
%%-------------------------------
-spec(agent_update_licensed(Agent :: #agent{})->{Statment :: string(), Values :: list()}).
agent_update_licensed(#agent{agent_phone_number = AgentPhoneNumber,licensed = Licensed})->
  {<<"UPDATE agent_by_phone_number SET licensed = ? WHERE agent_phone_number=?">>,
    [{licensed,Licensed},{agent_phone_number,AgentPhoneNumber}]}.

%%----------------------------
%% @doc generates query to activate or deactivate an agent
%%-------------------------------
-spec(agent_update_activated(Agent :: #agent{})->{Statment :: string(), Values :: list()}).
agent_update_activated(#agent{agent_phone_number = AgentPhoneNumber,activated = Activated})->
  {<<"UPDATE agent_by_phone_number SET activated = ? WHERE agent_phone_number=?">>,
    [{activated,Activated},{agent_phone_number,AgentPhoneNumber}]}.


%%----------------------------
%% @doc generates query to block or unblock an agent
%%-------------------------------
-spec(agent_update_blocked(Agent :: #agent{})->{Statment :: string(), Values :: list()}).
agent_update_blocked(#agent{agent_phone_number = AgentPhoneNumber,blocked = Blocked})->
  {<<"UPDATE agent_by_phone_number SET blocked = ? WHERE agent_phone_number=?">>,
    [{blocked,Blocked},{agent_phone_number,AgentPhoneNumber}]}.


%%----------------------------
%% @doc generates query to activate or deactivate a customer
%%-------------------------------
-spec(customer_update_activated(Customer :: #customer{})->{Statment :: string(), Values :: list()}).
customer_update_activated(#customer{customer_phone_number = CustomerPhoneNumber,activated = Activated})->
  {<<"UPDATE customer_by_phone_number SET activated = ? WHERE customer_phone_number=?">>,
    [{activated,Activated},{customer_phone_number,CustomerPhoneNumber}]}.


%%----------------------------
%% @doc generates query to block or unblock a customer
%%-------------------------------
-spec(customer_update_blocked(Customer :: #customer{})->{Statment :: string(), Values :: list()}).
customer_update_blocked(#customer{customer_phone_number = CustomerPhoneNumber,blocked = Blocked})->
  {<<"UPDATE customer_by_phone_number SET blocked = ? WHERE customer_phone_number=?">>,
    [{blocked,Blocked},{customer_phone_number,CustomerPhoneNumber}]}.

%%%==============================================
%%% INTERNAL FUNCTIONS
%%%===============================================
get_question_marks(Number) ->
  list_util:drop_last(lists:flatten(list_util:duplicate("?,", Number))).

%% @doc will add the bucket to params, values,names and question marks
%% and will return them in that order
add_bucket(BucketValue, Params, Values, Names, QuestionMarks) ->
  {[{bucket, BucketValue} | Params], [BucketValue | Values], "bucket," ++ Names, QuestionMarks ++ ",?"}.

get_agent_params(Agent)->
  [
    {agent_phone_number, Agent#agent.agent_phone_number},
    {parent_phone_number, Agent#agent.parent_phone_number},
    {parent_set, Agent#agent.parent_set},
    {national_id, Agent#agent.national_id},
    {first_name, Agent#agent.first_name},
    {last_name, Agent#agent.last_name},
    {date_of_birth,Agent#agent.date_of_birth},
    {password, Agent#agent.password},
    {security_question,Agent#agent.security_question},
    {security_answer,Agent#agent.security_answer},
    {next_of_kin_name,Agent#agent.next_of_kin_name},
    {next_of_kin_relation,Agent#agent.next_of_kin_relation},
    {next_of_kin_phone_number,Agent#agent.next_of_kin_phone_number},
    {gender,Agent#agent.gender},
    {email, Agent#agent.email},
    {country,Agent#agent.country},
    {activated,Agent#agent.activated},
    {blocked,Agent#agent.blocked},
    {network, Agent#agent.network},
    {middle_name,Agent#agent.middle_name},
    {district,Agent#agent.district},
    {city,Agent#agent.city},
    {licensed, Agent#agent.licensed},
    {agent_set, Agent#agent.agent_set}

  ].

get_customer_params(Customer)->
 [
{customer_phone_number,Customer#customer.customer_phone_number},
{agent_phone_number,Customer#customer.agent_phone_number},
{agent_set, Customer#customer.agent_set},
{password, Customer#customer.password},
{security_question,Customer#customer.security_question},
{security_answer,Customer#customer.security_answer},
{first_name, Customer#customer.first_name},
{last_name, Customer#customer.last_name},
{email, Customer#customer.email},
{country,Customer#customer.country},
{activated,Customer#customer.activated},
{blocked,Customer#customer.blocked},
{network, Customer#customer.network},
{middle_name,Customer#customer.middle_name},
{district,Customer#customer.district},
{city,Customer#customer.city}
].

get_transaction_params(Transaction)->

  {TimestampNow, _TimestampToday, _TimestampMonth, _TimestampYear} = util:getTimeStamps(),
  Trace = case Transaction#chapchap_transaction.trace of
            undefined -> undefined;
            Else -> util:convert_term_to_string(Else)

          end,
  Message = case Transaction#chapchap_transaction.message of
              undefined -> undefined;
              Else1 -> util:convert_term_to_string(Else1)

            end,
  Amount = case Transaction#chapchap_transaction.amount of
             undefined -> undefined;
             Binary when is_binary(Binary) ->
               util:convert_binary_to_float_or_integer(Binary, fun(_,_,_) -> undefined end);
             Integer when is_integer(Integer) -> Integer;
             Float when is_float(Float) -> Float;
             _ -> undefined

           end,
  HandleIsNotBinary = fun(Value) when is_binary (Value) -> Value;
    (Value)-> lists:flatten(io_lib:format("~p", [Value])) end,
  ArgsList =
    case Transaction#chapchap_transaction.args_list of
      TheArgsList when is_list(TheArgsList) ->[{Key,HandleIsNotBinary(TheValue)} || {Key,TheValue} <-TheArgsList ];
      _ -> undefined
    end,
  ApiUser = util:get_user(Transaction#chapchap_transaction.api_user),
  Processor =  Transaction#chapchap_transaction.processor_name,

  CustomerPhoneNumber = validator:replace_white_space(Transaction#chapchap_transaction.customer_phone_number),
  AgentPhoneNumber =  validator:replace_white_space(Transaction#chapchap_transaction.agent_phone_number),
  RawParams = [
    {transaction_id ,Transaction#chapchap_transaction.transaction_id },
    {process_step , Transaction#chapchap_transaction.process_step}
%%     {name, Transaction#chapchap_transaction.name},
%%     {agent_phone_number, AgentPhoneNumber},
%%     {customer_phone_number, CustomerPhoneNumber},
%%     {args_list,ArgsList},
%%     {state,Transaction#chapchap_transaction.state},
%%     {operation,Transaction#chapchap_transaction.operation},
%%     {receipt_id,Transaction#chapchap_transaction.receipt_id},
%%     {commission,Transaction#chapchap_transaction.commission},
%%     {agent_level, Transaction#chapchap_transaction.agent_level},
%%     {time, TimestampNow},
%%     {trace, Trace},
%%     {message, Message},
%%     {service_provider_id,Transaction#chapchap_transaction.service_provider_id},
%%     {amount,Amount},
%%     {type ,Transaction#chapchap_transaction.type},
%%     {retry_count, Transaction#chapchap_transaction.retry_count},
%%     {max_retry_count , Transaction#chapchap_transaction.retry_count},
%%     {currency,Transaction#chapchap_transaction.currency},
%%     {processor,Processor},
%%     {api_user, ApiUser},
%%     {api_user_type,Transaction#chapchap_transaction.api_user_type},
%%     {network,Transaction#chapchap_transaction.network}
  ],
  Params = [{Key, Value} || {Key, Value} <- RawParams, Value /= undefined],
  Values = [Value || {_Key, Value} <- Params],
  Names = list_util:drop_last(lists:flatten([util:atom_to_string(Key) ++ "," || {Key, _Value} <- Params])),
  QuestionMarks = get_question_marks(length(Values)),
  {Params, Values, Names, QuestionMarks}
.


