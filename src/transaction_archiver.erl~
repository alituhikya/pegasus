%%%-------------------------------------------------------------------
%%% @author mb-spare
%%% @copyright (C) 2015, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 30. Nov 2015 2:09 PM
%%%-------------------------------------------------------------------
-module(transaction_archiver).
-author("mb-spare").

-behaviour(gen_server).

%% API
-export([start_link/1, archive/2, archive_sync/2,stop/1]).

%% gen_server callbacks
-export([init/1,
  handle_call/3,
  handle_cast/2,
  handle_info/2,
  terminate/2,
  code_change/3]).

-include("../include/pension_app_common.hrl").
-include("../deps/cqerl/include/cqerl.hrl").


%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Starts the server
%%
%% @end
%%--------------------------------------------------------------------
-spec(start_link(ArchiverState :: #archiver_state{}) ->
  {ok, Pid :: pid()} | ignore | {error, Reason :: term()}).
start_link(ArchiverState) ->

  gen_server:start_link({global, ArchiverState#archiver_state.archiver_id}, ?MODULE, ArchiverState, []).


-spec(archive(Pid :: pid(), Transation :: #pension_transaction{}) ->
  ok | error).
archive(Pid, Transaction) ->
  gen_server:cast(Pid, {archive, Transaction}).

%% @doc clean up of the transaction and transaction process must be considered if state is final
%% it will not be handled for synchronous calls, only for asycnhronous archives
-spec(archive_sync(Pid :: pid(), Transation :: #pension_transaction{}) ->
  ok | error).
archive_sync(Pid, Transaction) ->
  gen_server:call(Pid, {archive, Transaction}).

stop(Pid) ->
  gen_server:call(Pid, stop).
%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initializes the server
%%
%% @spec init(Args) -> {ok, State} |
%%                     {ok, State, Timeout} |
%%                     ignore |
%%                     {stop, Reason}
%% @end
%%--------------------------------------------------------------------
-spec(init(Args :: term()) ->
  {ok, State :: #archiver_state{}} | {ok, State :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term()} | ignore).
init(ArchiverState) ->
  process_flag(trap_exit, true),
  {ok, ArchiverState}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling call messages
%%
%% @end
%%--------------------------------------------------------------------
-spec(handle_call(Request :: term(), From :: {pid(), Tag :: term()},
    State :: #archiver_state{}) ->
  {reply, Reply :: term(), NewState :: #archiver_state{}} |
  {reply, Reply :: term(), NewState :: #archiver_state{}, timeout() | hibernate} |
  {noreply, NewState :: #archiver_state{}} |
  {noreply, NewState :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term(), Reply :: term(), NewState :: #archiver_state{}} |
  {stop, Reason :: term(), NewState :: #archiver_state{}}).
handle_call({archive, Transaction}, _From, State) ->
  batch_insert(fun cqerl:run_query/2, {ok, void}, Transaction),

  {reply, ok, State};

handle_call(stop, _From, State) ->
  {stop, normal, shut_down, State};

handle_call(_Request, _From, State) ->
  {reply, ok, State}.


%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling cast messages
%%
%% @end
%%--------------------------------------------------------------------
-spec(handle_cast(Request :: term(), State :: #archiver_state{}) ->
  {noreply, NewState :: #archiver_state{}} |
  {noreply, NewState :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term(), NewState :: #archiver_state{}}).

handle_cast({archive, Transaction}, State) ->
  Ref = batch_insert(fun cqerl:send_query/2, ref, Transaction),
  handle_finish(Transaction,State,Ref),
  %  batch_insert(fun cqerl:run_query/2,{ok,void},Transaction),
  {noreply, State};

handle_cast(_Request, State) ->
  {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling all non call/cast messages
%%
%% @spec handle_info(Info, State) -> {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
-spec(handle_info(Info :: timeout() | term(), State :: #archiver_state{}) ->
  {noreply, NewState :: #archiver_state{}} |
  {noreply, NewState :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term(), NewState :: #archiver_state{}}).


handle_info(_Info, State) ->
  {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_server when it is about to
%% terminate. It should be the opposite of Module:init/1 and do any
%% necessary cleaning up. When it returns, the gen_server terminates
%% with Reason. The return value is ignored.
%%
%% @spec terminate(Reason, State) -> void()
%% @end
%%--------------------------------------------------------------------
-spec(terminate(Reason :: (normal | shutdown | {shutdown, term()} | term()),
    State :: #archiver_state{}) -> term()).
terminate(_Reason, _State) ->
  ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%%
%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}
%% @end
%%--------------------------------------------------------------------
-spec(code_change(OldVsn :: term() | {down, term()}, State :: #archiver_state{},
    Extra :: term()) ->
  {ok, NewState :: #archiver_state{}} | {error, Reason :: term()}).
code_change(_OldVsn, State, _Extra) ->
  {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================

batch_insert(F, Result, Transaction) ->
%%   {ok, CassandraContactPoint} = case application:get_env(cassandra_contact_point) of
%%                                   undefined ->  {ok,"127.0.0.1"};
%%                                    A -> A
%%                                 end,
%%   {ok, CassandraPort} = case application:get_env(cassandra_port) of
%%                           undefined -> {ok,9042};
%%                           B ->B
%%                           end,
%%   {ok, KeySpace} =  case application:get_env(keyspace) of
%%                       undefined -> {ok,"pension_keyspace"};
%%                       C->C
%%                     end,
  CassandraSettings = env_utiility:get_cassandra_settings(),
  CassandraContactPoint = CassandraSettings#cassandra_settings.cassandra_contact_point,
  CassandraPort = CassandraSettings#cassandra_settings.cassandra_port,
  KeySpace = CassandraSettings#cassandra_settings.keyspace,
  {ok, Client} = cqerl:new_client({CassandraContactPoint, CassandraPort}, [{keyspace,KeySpace}]),
  {  Params,
    ParamsBucket,
    _Values,
    _ValuesBucket, [Ins1, Ins2, Ins3]} = cquery_builder:batch_insert_from_transaction(Transaction),
  InsertQ1 = #cql_query{statement = Ins1},
  InsertQ2 = #cql_query{statement = Ins2},
  InsertQ3 = #cql_query{statement = Ins3},
  case Result of
    ref -> run_upsert(F, Client, InsertQ1, InsertQ2, InsertQ3 ,Params,ParamsBucket);
    R -> R = run_upsert(F, Client, InsertQ1, InsertQ2, InsertQ3 ,Params,ParamsBucket)
  end,
  update_counter(F, Client, Transaction),
  cqerl:close_client(Client).

run_upsert(F, Client, InsertQ1, InsertQ2, InsertQ3, Params, ParamsBucket) ->

  F(Client, #cql_query_batch{
    mode = ?CQERL_BATCH_LOGGED,
    queries = [
      InsertQ1#cql_query{values = Params},
      InsertQ2#cql_query{values = ParamsBucket},
      InsertQ3#cql_query{values = ParamsBucket}
    ]
  }).

update_counter(F, Client, Transaction) ->
  case cquery_builder:update_counter(Transaction) of
    false -> do_nothing;
    {ParamsCounter1, ParamsCounter2, [InsCounter1, InsCounter2]} ->
      InsertQ6 = #cql_query{statement = InsCounter1},
      InsertQ7 = #cql_query{statement = InsCounter2},
      F(Client, #cql_query_batch{
        mode = ?CQERL_BATCH_COUNTER,
        queries = [
          InsertQ6#cql_query{values = ParamsCounter1},
          InsertQ7#cql_query{values = ParamsCounter2}
        ]
      })
%%     {ParamsCounter1, ParamsCounter2, [InsCounter1, InsCounter2]} ->
%%     {ok, void} = cqerl:run_query(Client, #cql_query{
%%         statement = <<"UPDATE entries4 SET count = count + ? WHERE key = ?;">>,
%%         values = [
%%           {key, "First counter"},
%%           {count, 18}
%%         ]
%%     }),
%%
%%   {ok, void} = cqerl:run_query(Client, #cql_query{
%%     statement = "UPDATE entries4 SET count = count + 10 WHERE key = ?;",
%%     values = [{key, "First counter"}]
%%   })

  end.
handle_finish (#pension_transaction{state = State,type = [_,Type]},#archiver_state{transaction_id = Pid,archiver_id =_ArchiverPid },Ref)->

  %% if final state then stop transaction process and if transaction terminated then terminate archiver
  %% some states are only considered final if they were processed by the async_processor since
  case {State,Type} of
    {?STATE_PROCESSING_ERROR ,_} ->handle_finish(Ref,Pid);
    {?STATE_TRANSACTION_RETRY_FAILED,async} -> handle_finish(Ref,Pid);
    {?STATE_TRANSACTION_REQUEUED,async} ->handle_finish(Ref,Pid);
    {?STATE_MAX_RETRY_EXCEEDED,async} ->handle_finish(Ref,Pid);
    {?STATE_PAYMENT_CONFIRMED,async} ->handle_finish(Ref,Pid);
    {?STATE_PAYMENT_INITIALIZED,sync} ->handle_finish(Ref,Pid);
    {?STATE_END_IN_ERROR,sync} ->handle_finish(Ref,Pid);
   % {?STATE_TRANSACTION_PROCESS_TERMINATED,_} -> transaction_archiver:stop(ArchiverPid);
    _-> do_nothing
  end.
handle_finish(Ref,TransactionPid)->
  receive
    {result, Ref, _Result} ->
      transaction:stop(TransactionPid),
      ok
  end.