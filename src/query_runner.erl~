%%%-------------------------------------------------------------------
%%% @author mb-spare
%%% @copyright (C) 2016, <COMPANY>
%%% @doc
%%%
%%% @end
%%% Created : 01. May 2016 8:11 PM
%%%-------------------------------------------------------------------
-module(query_runner).
-author("mb-spare").

-include("../include/chapchap_app_common.hrl").
-include("../deps/cqerl/include/cqerl.hrl").
%% API
-export(
[
  get_cassandra_client/0,

  run_batch/2,
  run_batch/4,

  run_query/1,
  run_query/2,
  run_query/3,
  run_query_async/1,

  pg_connect/0,
  pg_close/1,

  pg_run_equery/2,
  pg_run_squery/2,

  pg_connect_pool/0,
  transfer_amount/3,
  update_available_account/1,
  get_available_account_total/1,
  update_available_accounts/1,
  pg_run_query/1,
  create_available_account/1
]).

%%--------------------------------------------------------------------
%% @doc
%% gets the cqerl cassandra client
%% %cqerl:close_client(Client); with new mode not needed see cqerl read me
%% @end
%%--------------------------------------------------------------------
-spec(get_cassandra_client() -> Client :: term()).
get_cassandra_client() ->
  CassandraSettings = env_utiility:get_cassandra_settings(),
  CassandraContactPoint = CassandraSettings#cassandra_settings.cassandra_contact_point,
  CassandraPort = CassandraSettings#cassandra_settings.cassandra_port,
  KeySpace = CassandraSettings#cassandra_settings.keyspace,
  {ok, Client} = cqerl:get_client({CassandraContactPoint, CassandraPort}, [{keyspace, KeySpace}]),
  Client.


%%--------------------------------------------------------------------
%% @doc
%% for running batch queries
%% List is expected to be list of tuples of {Statement, Values}
%% Values is expected to be at List of tuples of {columnName, Value}
%% where columnName can be a binary string or String
%% %cqerl:close_client(Client); with new mode not needed see cqerl read me
%%
%% @end
%%--------------------------------------------------------------------
run_batch(Type, List) ->
  Client = get_cassandra_client(),
  run_batch(Type, List, Client).

run_batch(counter_async, List, Client) ->
  run_batch(fun cqerl:send_query/2, List, Client, ?CQERL_BATCH_COUNTER);

run_batch(counter_sync, List, Client) ->
  run_batch(fun cqerl:run_query/2, List, Client, ?CQERL_BATCH_COUNTER)
;

run_batch(async, List, Client) ->
  run_batch(fun cqerl:send_query/2, List, Client, ?CQERL_BATCH_LOGGED);

run_batch(sync, List, Client) ->
  run_batch(fun cqerl:run_query/2, List, Client, ?CQERL_BATCH_LOGGED).

run_batch(Type, List, Client, BatchType) ->
  Queries = [#cql_query{statement = Statement, values = Values} || {Statement, Values} <- List],
  Type(Client, #cql_query_batch{mode = BatchType, queries = Queries}).

%%--------------------------------------------------------------------
%% @doc
%% for running queries
%% Values is expected to be at List of tuples of {columnName, Value}
%% where columnName can be a binaryString or String
%% %cqerl:close_client(Client); with new mode not needed see cqerl read me
%% @end
%%--------------------------------------------------------------------
run_query(Statement) ->
  Client = get_cassandra_client(),
  {ok, _Result} = cqerl:run_query(Client, #cql_query{statement = Statement}).
run_query_async(Statement) ->
  Client = get_cassandra_client(),
  cqerl:send_query(Client, #cql_query{statement = Statement}).

run_query(Type, Params) ->
  Client = get_cassandra_client(),
  run_query(Type, Params, Client).

-spec(run_query(sync | async | get_result_list, {Statment :: binary(), Values :: list()}, Client :: term()) -> {ok, Result :: term()} | list() | term()).
run_query(sync, {Statement, Values}, Client) ->
  cqerl:run_query(Client, #cql_query{statement = Statement, values = Values});

run_query(async, {Statement, Values}, Client) ->
  cqerl:send_query(Client, #cql_query{statement = Statement, values = Values});

run_query(get_result_list, {Statement, Values}, Client) ->
  {ok, Result} = cqerl:run_query(Client, #cql_query{statement = Statement, values = Values}),
  Return = cqerl:all_rows(Result),
  Return.

pg_connect() ->
  PgSettings = env_utiility:get_postgres_settings(),
  {ok, C} = epgsql:connect(
    PgSettings#postgres_settings.pg_ip,
    PgSettings#postgres_settings.pg_username,
    PgSettings#postgres_settings.pg_password,
    [
      {database, PgSettings#postgres_settings.pg_database},
      {timeout, PgSettings#postgres_settings.pg_connect_timeout}
    ]),
  C.
pg_connect_pool() ->
  PgSettings = env_utiility:get_postgres_settings(),
  pgapp:connect([
    {size, 10},
    {database, PgSettings#postgres_settings.pg_database},
    {username, PgSettings#postgres_settings.pg_username},
    {password, PgSettings#postgres_settings.pg_password}
  ]).

pg_close(C) ->
  ok = epgsql:close(C).

pg_run_equery(C, {Statement, Parameters}) ->
  epgsql:equery(C, Statement, Parameters).

pg_run_squery(C, Query) ->
  epgsql:squery(C, Query).

pg_run_query(Query) ->
  pgapp:equery(Query, []).

%% @doc transfers amount from one available account to another
-spec(transfer_amount(Amount :: integer(),From :: term(), To :: term())->{ok,1} | {error, term()}).
transfer_amount(Amount, From, To) ->
  Result = pgapp:with_transaction(fun() ->
    Result1 = pgapp:equery("UPDATE account SET total=total-$1 WHERE phone_number=$2; ", [Amount, From]),
    Result2 = pgapp:equery("UPDATE account SET total=total+$1 WHERE phone_number=$2; ", [Amount, To]),
    [Result1, Result2]
  end),
  case Result of
    [{ok, Count}, {ok, Count}] -> {ok, Count};
    [
      {error, {error, error, _, check_violation,
        <<"new row for relation \"account\" violates check constraint \"positive_total\"">>, _}},
      _
    ] ->
      {error, insufficient_funds};
    [
      _,
      {error, {error, error, _, check_violation,
        <<"new row for relation \"account\" violates check constraint \"positive_total\"">>, _}}

    ] ->
      {error, insufficient_funds};
    Error -> {error, Error}
  end
.

%% @doc creates account available
-spec(create_available_account(#customer{} | #agent{} | binary() | string()) -> {ok ,1} | {error, already_exists} | {error, Error :: term()}).
create_available_account(#customer{customer_phone_number = PhoneNumber}) ->
  create_available_account(PhoneNumber);
create_available_account(#agent{agent_phone_number = PhoneNumber}) ->
  create_available_account(PhoneNumber);
create_available_account(PhoneNumber) ->
  Result = pgapp:with_transaction(fun() ->
    pgapp:equery("insert into account (phone_number,total) values  ($1,0);", [PhoneNumber])
  end),
  case Result of
    {ok, Count} -> {ok, Count};
    {error, {_, _, _, unique_violation, _, _}} ->
      {error, already_exists};
    Error -> Error
  end
.

%% @doc updates account available based on account action provided
update_available_account(#account_action{account_number = PhoneNumber, amount = Amount}) ->
  Result = pgapp:with_transaction(fun() ->
    pgapp:equery("UPDATE account SET total=total+$1 WHERE phone_number=$2; ", [Amount, PhoneNumber])
  end),
  case Result of
    {ok, Count} -> {ok, Count};
    {error, {error, error, _, check_violation,
      <<"new row for relation \"account\" violates check constraint \"positive_total\"">>, _}} ->
      {error, insufficient_funds};
    Error -> Error
  end
.

%% @doc returns the accounts total available
-spec(get_available_account_total(PhoneNumber :: binary())->integer() | float() | {error,Error :: term()}).
get_available_account_total(PhoneNumber) ->
  Return = pgapp:with_transaction(fun() ->
    pgapp:equery("select total from account where phone_number = $1", [PhoneNumber])
  end),

  case Return of
    {ok, _Column, [{TotalBinary}]} -> util:convert_list_to_float_or_integer(binary_to_list(TotalBinary),
      fun(_, _, _) -> {error, failed_to_convert} end);
    {ok, _Column, []} -> 0;
    Error -> Error
  end.

%% @doc updates account available based on list of account actions provided
-spec(update_available_accounts(AccountActions :: list()) -> {ok ,Result :: list()} | {error,Error :: term()}).
update_available_accounts(AccountActions) ->
  MapFun = fun(#account_action{amount = Amount, account_number = PhoneNumber}) ->
    pgapp:equery("UPDATE account SET total=total+$1 WHERE phone_number=$2; ", [Amount, PhoneNumber])
  end,
  Result = pgapp:with_transaction(fun() ->
    lists:map(MapFun, AccountActions)
%%    [ pgapp:equery("UPDATE account SET total=total+? WHERE phone_number=?; ", [Amount,PhoneNumber])
%%    || #account_action{amount = Amount,account_number = PhoneNumber} <- AccountActions]

  end),
  case lists:keyfind(error, 1, Result) of
    {error, {error, error, _, check_violation,
      <<"new row for relation \"account\" violates check constraint \"positive_total\"">>, _}} ->
      {error, insufficient_funds};
    {error, Error} -> {error, Error};
    false -> {ok, Result}
  end
.


