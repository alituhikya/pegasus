%%%-------------------------------------------------------------------
%%% @author mb-spare
%%% @copyright (C) 2015, <COMPANY>
%%% @doc
%%% @todo termination and clean up
%%% @end
%%% Created : 30. Nov 2015 2:09 PM
%%%-------------------------------------------------------------------
-module(archiver).
-author("mb-spare").

-behaviour(gen_server).

%% API
-export([
  start_link/1,
  archive_agent_transaction/2,
  archive_customer_transaction/2,
  archive_service_provider_transaction/2,
  archive/2,
  archive_sync/2,
  stop/1]).

%% gen_server callbacks
-export([init/1,
  handle_call/3,
  handle_cast/2,
  handle_info/2,
  terminate/2,
  code_change/3]).

-include("../include/chapchap_app_common.hrl").
-include("../deps/cqerl/include/cqerl.hrl").


%%%===================================================================
%%% API
%%%===================================================================

%%--------------------------------------------------------------------
%% @doc
%% Starts the server
%%
%% @end
%%--------------------------------------------------------------------
-spec(start_link(ArchiverState :: #archiver_state{}) ->
  {ok, Pid :: pid()} | ignore | {error, Reason :: term()}).
start_link(ArchiverState) ->

  gen_server:start_link({global, ArchiverState#archiver_state.archiver_id}, ?MODULE, ArchiverState, []).

%% the archiver can either be archive which is for a normal transaction or it can be
%% archive_query which is for archiving a query on the system
-spec(archive(Pid :: pid(), Record :: term()) ->
  ok | error).
archive(Pid, Record ) ->
 gen_server:call(Pid,  Record).
%gen_server:cast(Pid,  Record).

archive_agent_transaction(Pid,Transaction)->
  %gen_server:call(Pid,  {agent,Transaction}).
  gen_server:cast(Pid,  {agent,Transaction}).

archive_customer_transaction(Pid,Transaction ) ->
  %gen_server:call(Pid,  {customer,Transaction}).
  gen_server:cast(Pid,  {customer,Transaction}).
archive_service_provider_transaction(Pid, Record ) ->
  %gen_server:call(Pid, {service_provider,Record}).
  gen_server:cast(Pid,  {service_provider,Record}).

%% @doc clean up of the transaction and transaction process must be considered if state is final
%% it will not be handled for synchronous calls, only for asycnhronous archives
-spec(archive_sync(Pid :: pid(),  Record :: term()) ->
  ok | error).
archive_sync(Pid, Record) ->
  gen_server:call(Pid, Record).

stop(Pid) ->
  gen_server:call(Pid, stop).
%%%===================================================================
%%% gen_server callbacks
%%%===================================================================

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Initializes the server
%%
%% @spec init(Args) -> {ok, State} |
%%                     {ok, State, Timeout} |
%%                     ignore |
%%                     {stop, Reason}
%% @end
%%--------------------------------------------------------------------
-spec(init(Args :: term()) ->
  {ok, State :: #archiver_state{}} | {ok, State :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term()} | ignore).
init(ArchiverState) ->
  process_flag(trap_exit, true),
  {ok, ArchiverState}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling call messages
%%
%% @end
%%--------------------------------------------------------------------
-spec(handle_call(Request :: term(), From :: {pid(), Tag :: term()},
    State :: #archiver_state{}) ->
  {reply, Reply :: term(), NewState :: #archiver_state{}} |
  {reply, Reply :: term(), NewState :: #archiver_state{}, timeout() | hibernate} |
  {noreply, NewState :: #archiver_state{}} |
  {noreply, NewState :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term(), Reply :: term(), NewState :: #archiver_state{}} |
  {stop, Reason :: term(), NewState :: #archiver_state{}}).
handle_call({agent,Transaction}, _From, State = #archiver_state{process_step = ProcessStep,type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  case Transaction#chapchap_transaction.account_actions of
    [] -> nothing;
    List when is_list(List)->
      QueryParams1 = query_builder:insert_account_actions(Transaction#chapchap_transaction.account_actions),
      query_runner:run_batch(sync,QueryParams1);
    _-> nothing
  end,
  QueryParams = query_builder:batch_insert_agents_transaction(Transaction#chapchap_transaction{process_step = NewProcessStep}),
  query_runner:run_batch(sync,QueryParams),
  handle_finish (call,undefined,Transaction,State#archiver_state{process_step = NewProcessStep});
handle_call({customer,Transaction}, _From, State = #archiver_state{process_step = ProcessStep,type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  case Transaction#chapchap_transaction.account_actions of
    [] -> nothing;
    List when is_list(List)->
      QueryParams1 = query_builder:insert_account_actions(Transaction#chapchap_transaction.account_actions),
      query_runner:run_batch(sync,QueryParams1);
    _-> nothing
  end,
  QueryParams = query_builder:batch_insert_customers_transaction(Transaction#chapchap_transaction{process_step = NewProcessStep}),
  query_runner:run_batch(sync,QueryParams),
  handle_finish (call,undefined,Transaction,State#archiver_state{process_step = NewProcessStep});
handle_call({service_provider,Transaction}, _From, State = #archiver_state{process_step = ProcessStep,type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  QueryParams = query_builder:batch_insert_service_providers_transaction(Transaction#chapchap_transaction{process_step = NewProcessStep}),
  query_runner:run_batch(sync,QueryParams),
  handle_finish (call,undefined,Transaction,State#archiver_state{process_step = NewProcessStep});

%% for archiving a transacion with system
handle_call(Transaction, _From, State = #archiver_state{process_step = ProcessStep,type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  QueryParams = query_builder:batch_insert_from_transaction(Transaction#chapchap_transaction{process_step = NewProcessStep}),
  query_runner:run_batch(sync,QueryParams),
  handle_finish (call,undefined,Transaction,State#archiver_state{process_step = NewProcessStep});

%% for archiving a query with system
handle_call(Request, _From, State = #archiver_state{process_step = ProcessStep,type = query}) ->
  NewProcessStep = ProcessStep + 1,
  QueryParams = query_builder:batch_insert_from_request(Request#chapchap_request{process_step = NewProcessStep}),
  query_runner:run_batch(sync,QueryParams),
  handle_finish (call,undefined,Request,State#archiver_state{process_step = NewProcessStep});



handle_call(stop, _From, State) ->
  {stop, normal, shutdown, State};

handle_call(_Request, _From, State) ->
  {reply, ok, State}.


%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling cast messages
%%
%% @end
%%--------------------------------------------------------------------
-spec(handle_cast(Request :: term(), State :: #archiver_state{}) ->
  {noreply, NewState :: #archiver_state{}} |
  {noreply, NewState :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term(), NewState :: #archiver_state{}}).

handle_cast( {agent,Transaction}, State = #archiver_state{process_step = ProcessStep, type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  case Transaction#chapchap_transaction.account_actions of
    [] -> nothing;
    List when is_list(List)->
      QueryParams1 = query_builder:insert_account_actions(Transaction#chapchap_transaction.account_actions),
      query_runner:run_batch(async,QueryParams1);
    _-> nothing
  end,
  QueryParams = query_builder:batch_insert_agents_transaction(Transaction),
  Ref = query_runner:run_batch(async,QueryParams),
  handle_finish (cast,Ref,Transaction,State#archiver_state{process_step = NewProcessStep});
handle_cast( {customer,Transaction}, State = #archiver_state{process_step = ProcessStep, type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  case Transaction#chapchap_transaction.account_actions of
    [] -> nothing;
    List when is_list(List)->
      QueryParams1 = query_builder:insert_account_actions(Transaction#chapchap_transaction.account_actions),
      query_runner:run_batch(async,QueryParams1);
    _-> nothing
  end,
  QueryParams = query_builder:batch_insert_customers_transaction(Transaction),
  Ref = query_runner:run_batch(async,QueryParams),
  handle_finish (cast,Ref,Transaction,State#archiver_state{process_step = NewProcessStep});
handle_cast({service_provider,Transaction}, State = #archiver_state{process_step = ProcessStep, type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  QueryParams = query_builder:batch_insert_service_provider_transaction(Transaction#chapchap_transaction{process_step = NewProcessStep}),
  Ref = query_runner:run_batch(async,QueryParams),
  handle_finish (cast,Ref,Transaction,State#archiver_state{process_step = NewProcessStep});

%% for archiving a transacion with system
handle_cast( Transaction, State = #archiver_state{process_step = ProcessStep, type = transaction}) ->
  NewProcessStep = ProcessStep + 1,
  QueryParams = query_builder:batch_insert_from_transaction(Transaction#chapchap_transaction{process_step = NewProcessStep}),
  Ref = query_runner:run_batch(async,QueryParams),
  handle_finish (cast,Ref,Transaction,State#archiver_state{process_step = NewProcessStep});

%% for archiving a query on the system
handle_cast(Request, State = #archiver_state{process_step = ProcessStep,type = query}) ->
  NewProcessStep = ProcessStep + 1,
  QueryParams = query_builder:batch_insert_from_request(Request#chapchap_request{process_step = NewProcessStep}),
  Ref = query_runner:run_batch(async,QueryParams),
  handle_finish(cast,Ref,Request,State#archiver_state{process_step = NewProcessStep});



handle_cast(_Request, State) ->
  {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Handling all non call/cast messages
%%
%% @spec handle_info(Info, State) -> {noreply, State} |
%%                                   {noreply, State, Timeout} |
%%                                   {stop, Reason, State}
%% @end
%%--------------------------------------------------------------------
-spec(handle_info(Info :: timeout() | term(), State :: #archiver_state{}) ->
  {noreply, NewState :: #archiver_state{}} |
  {noreply, NewState :: #archiver_state{}, timeout() | hibernate} |
  {stop, Reason :: term(), NewState :: #archiver_state{}}).


handle_info(_Info, State) ->
  {noreply, State}.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% This function is called by a gen_server when it is about to
%% terminate. It should be the opposite of Module:init/1 and do any
%% necessary cleaning up. When it returns, the gen_server terminates
%% with Reason. The return value is ignored.
%%
%% @spec terminate(Reason, State) -> void()
%% @end
%%--------------------------------------------------------------------
-spec(terminate(Reason :: (normal | shutdown | {shutdown, term()} | term()),
    State :: #archiver_state{}) -> term()).
terminate(_Reason, _State) ->
  ok.

%%--------------------------------------------------------------------
%% @private
%% @doc
%% Convert process state when code is changed
%%
%% @spec code_change(OldVsn, State, Extra) -> {ok, NewState}
%% @end
%%--------------------------------------------------------------------
-spec(code_change(OldVsn :: term() | {down, term()}, State :: #archiver_state{},
    Extra :: term()) ->
  {ok, NewState :: #archiver_state{}} | {error, Reason :: term()}).
code_change(_OldVsn, State, _Extra) ->
  {ok, State}.

%%%===================================================================
%%% Internal functions
%%%===================================================================


handle_finish (CastOrCall,Ref,#chapchap_request{state = State,type =Type,async_runner_pid = AsyncPid},ArchiverState = #archiver_state{id = _Pid,archiver_id =_ArchiverPid })->
  %% if final state then stop transaction process and if transaction terminated then terminate archiver
  %% some states are only considered final if they were processed by the async_processor since
  case {State,Type} of
    {?STATE_PROCESSING_ERROR ,_} ->handle_finish_terminate(CastOrCall,Ref,AsyncPid,ArchiverState);
    {?STATE_END_IN_SUCCESS,_} ->handle_finish_terminate(CastOrCall,Ref,AsyncPid,ArchiverState);
    {?STATE_END_IN_ERROR,_} ->handle_finish_terminate(CastOrCall,Ref,AsyncPid,ArchiverState);
    {?STATE_TRANSACTION_RETRY_FAILED,async} -> handle_finish_terminate(CastOrCall,Ref,AsyncPid,ArchiverState);
    {?STATE_TRANSACTION_REQUEUED,async} ->handle_finish_terminate(CastOrCall,Ref,AsyncPid,ArchiverState);
    {?STATE_MAX_RETRY_EXCEEDED,async} ->handle_finish_terminate(CastOrCall,Ref,AsyncPid,ArchiverState);
    {?STATE_ASYNC_PROCESS_TERMINATED,_} -> handle_finish_terminate(CastOrCall,terminate,AsyncPid,ArchiverState);
    _-> handle_finish_no_terminate(CastOrCall,ArchiverState)

  end;


handle_finish (CastOrCall,Ref,#chapchap_transaction{state = State,type = Type},ArchiverState = #archiver_state{id = _Pid,archiver_id =_ArchiverPid })->
  %% if final state then stop transaction process and if transaction terminated then terminate archiver
  %% some states are only considered final if they were processed by the async_processor since
  TransactionPid = undefined,
  case {State,Type} of
    {?STATE_PROCESSING_ERROR ,_} ->handle_finish_terminate(CastOrCall,Ref,TransactionPid,ArchiverState);
    {?STATE_END_IN_SUCCESS,_} ->handle_finish_terminate(CastOrCall,Ref,TransactionPid,ArchiverState);
    {?STATE_END_IN_ERROR,_} ->handle_finish_terminate(CastOrCall,Ref,TransactionPid,ArchiverState);
    {?STATE_TRANSACTION_RETRY_FAILED,async} -> handle_finish_terminate(CastOrCall,Ref,TransactionPid,ArchiverState);
    {?STATE_TRANSACTION_REQUEUED,async} ->handle_finish_terminate(CastOrCall,Ref,TransactionPid,ArchiverState);
    {?STATE_MAX_RETRY_EXCEEDED,async} ->handle_finish_terminate(CastOrCall,Ref,TransactionPid,ArchiverState);
   {?STATE_ASYNC_PROCESS_TERMINATED,_} -> handle_finish_terminate(CastOrCall,terminate,TransactionPid,ArchiverState);
    _-> handle_finish_no_terminate(CastOrCall,ArchiverState)

  end.

%% if async process is terminated abrutly then terminate archiver
handle_finish_terminate(call,termnate,_TransactionPid,ArchiverState)->
  {stop, normal, shutdown, ArchiverState};

%% If async process doensnt exist
handle_finish_terminate(call,_Ref,undefined,ArchiverState)->
  {stop, normal, shutdown, ArchiverState};

%% if there is no Ref ie call is synchronous then terminate transaction process then terminate archiver
handle_finish_terminate(call,undefined,TransactionPid,ArchiverState)->
  shutdown = async_runner:stop(TransactionPid),
  {stop, normal, shutdown, ArchiverState};

%% if there is Ref ie call is asynchronous then wait to recieve
%% confirmation that it was run then terminate transaction process then terminate archiver
handle_finish_terminate(call,Ref,TransactionPid,ArchiverState)->
  receive
    {result, Ref, _Result} ->
   shutdown =   async_runner:stop(TransactionPid),
      {stop, normal, shutdown, ArchiverState}
  end;

%% equivalent to above but for cast
handle_finish_terminate(cast,termnate,_TransactionPid,ArchiverState)->
  {stop, normal, ArchiverState};

handle_finish_terminate(cast,_Ref,undefined,ArchiverState)->
  {stop, normal, ArchiverState};

handle_finish_terminate(cast,undefined,TransactionPid,ArchiverState)->
  shutdown = async_runner:stop(TransactionPid),
  {stop, normal, ArchiverState};
handle_finish_terminate(cast,Ref,TransactionPid,ArchiverState)->
  receive
    {result, Ref, _Result} ->
   shutdown =   async_runner:stop(TransactionPid),
      {stop, normal, ArchiverState}
  end.

%% dont terminate
handle_finish_no_terminate(call,ArchiverState)->
  {reply, ok, ArchiverState};

handle_finish_no_terminate(cast,ArchiverState)->
  {noreply, ArchiverState}.